// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'view_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ViewEventTearOff {
  const _$ViewEventTearOff();

  _ToCountries toCountries() {
    return const _ToCountries();
  }

  _ToAreas toAreas(CountryBloc country) {
    return _ToAreas(
      country,
    );
  }

  _ToSubareas toSubareas(AreaBloc area) {
    return _ToSubareas(
      area,
    );
  }

  _ToRocks toRocks(SubareaBloc subarea) {
    return _ToRocks(
      subarea,
    );
  }

  _ToRoutes toRoutes(RockBloc rock) {
    return _ToRoutes(
      rock,
    );
  }

  _ToCountriesWithoutReload toCountriesWithoutReload() {
    return const _ToCountriesWithoutReload();
  }

  _ToAreasWithoutReload toAreasWithoutReload() {
    return const _ToAreasWithoutReload();
  }

  _ToSubareasWithoutReload toSubareasWithoutReload() {
    return const _ToSubareasWithoutReload();
  }

  _ToRocksWithoutReload toRocksWithoutReload() {
    return const _ToRocksWithoutReload();
  }

  _ToRoutesWithoutReload toRoutesWithoutReload() {
    return const _ToRoutesWithoutReload();
  }
}

/// @nodoc
const $ViewEvent = _$ViewEventTearOff();

/// @nodoc
mixin _$ViewEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ViewEventCopyWith<$Res> {
  factory $ViewEventCopyWith(ViewEvent value, $Res Function(ViewEvent) then) =
      _$ViewEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$ViewEventCopyWithImpl<$Res> implements $ViewEventCopyWith<$Res> {
  _$ViewEventCopyWithImpl(this._value, this._then);

  final ViewEvent _value;
  // ignore: unused_field
  final $Res Function(ViewEvent) _then;
}

/// @nodoc
abstract class _$ToCountriesCopyWith<$Res> {
  factory _$ToCountriesCopyWith(
          _ToCountries value, $Res Function(_ToCountries) then) =
      __$ToCountriesCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToCountriesCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToCountriesCopyWith<$Res> {
  __$ToCountriesCopyWithImpl(
      _ToCountries _value, $Res Function(_ToCountries) _then)
      : super(_value, (v) => _then(v as _ToCountries));

  @override
  _ToCountries get _value => super._value as _ToCountries;
}

/// @nodoc

class _$_ToCountries implements _ToCountries {
  const _$_ToCountries();

  @override
  String toString() {
    return 'ViewEvent.toCountries()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToCountries);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toCountries();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountries != null) {
      return toCountries();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toCountries(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountries != null) {
      return toCountries(this);
    }
    return orElse();
  }
}

abstract class _ToCountries implements ViewEvent {
  const factory _ToCountries() = _$_ToCountries;
}

/// @nodoc
abstract class _$ToAreasCopyWith<$Res> {
  factory _$ToAreasCopyWith(_ToAreas value, $Res Function(_ToAreas) then) =
      __$ToAreasCopyWithImpl<$Res>;
  $Res call({CountryBloc country});
}

/// @nodoc
class __$ToAreasCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToAreasCopyWith<$Res> {
  __$ToAreasCopyWithImpl(_ToAreas _value, $Res Function(_ToAreas) _then)
      : super(_value, (v) => _then(v as _ToAreas));

  @override
  _ToAreas get _value => super._value as _ToAreas;

  @override
  $Res call({
    Object? country = freezed,
  }) {
    return _then(_ToAreas(
      country == freezed
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as CountryBloc,
    ));
  }
}

/// @nodoc

class _$_ToAreas implements _ToAreas {
  const _$_ToAreas(this.country);

  @override
  final CountryBloc country;

  @override
  String toString() {
    return 'ViewEvent.toAreas(country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToAreas &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(country);

  @JsonKey(ignore: true)
  @override
  _$ToAreasCopyWith<_ToAreas> get copyWith =>
      __$ToAreasCopyWithImpl<_ToAreas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toAreas(country);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreas != null) {
      return toAreas(country);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toAreas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreas != null) {
      return toAreas(this);
    }
    return orElse();
  }
}

abstract class _ToAreas implements ViewEvent {
  const factory _ToAreas(CountryBloc country) = _$_ToAreas;

  CountryBloc get country => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToAreasCopyWith<_ToAreas> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToSubareasCopyWith<$Res> {
  factory _$ToSubareasCopyWith(
          _ToSubareas value, $Res Function(_ToSubareas) then) =
      __$ToSubareasCopyWithImpl<$Res>;
  $Res call({AreaBloc area});
}

/// @nodoc
class __$ToSubareasCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToSubareasCopyWith<$Res> {
  __$ToSubareasCopyWithImpl(
      _ToSubareas _value, $Res Function(_ToSubareas) _then)
      : super(_value, (v) => _then(v as _ToSubareas));

  @override
  _ToSubareas get _value => super._value as _ToSubareas;

  @override
  $Res call({
    Object? area = freezed,
  }) {
    return _then(_ToSubareas(
      area == freezed
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as AreaBloc,
    ));
  }
}

/// @nodoc

class _$_ToSubareas implements _ToSubareas {
  const _$_ToSubareas(this.area);

  @override
  final AreaBloc area;

  @override
  String toString() {
    return 'ViewEvent.toSubareas(area: $area)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToSubareas &&
            (identical(other.area, area) ||
                const DeepCollectionEquality().equals(other.area, area)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(area);

  @JsonKey(ignore: true)
  @override
  _$ToSubareasCopyWith<_ToSubareas> get copyWith =>
      __$ToSubareasCopyWithImpl<_ToSubareas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toSubareas(area);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareas != null) {
      return toSubareas(area);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toSubareas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareas != null) {
      return toSubareas(this);
    }
    return orElse();
  }
}

abstract class _ToSubareas implements ViewEvent {
  const factory _ToSubareas(AreaBloc area) = _$_ToSubareas;

  AreaBloc get area => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToSubareasCopyWith<_ToSubareas> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToRocksCopyWith<$Res> {
  factory _$ToRocksCopyWith(_ToRocks value, $Res Function(_ToRocks) then) =
      __$ToRocksCopyWithImpl<$Res>;
  $Res call({SubareaBloc subarea});
}

/// @nodoc
class __$ToRocksCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRocksCopyWith<$Res> {
  __$ToRocksCopyWithImpl(_ToRocks _value, $Res Function(_ToRocks) _then)
      : super(_value, (v) => _then(v as _ToRocks));

  @override
  _ToRocks get _value => super._value as _ToRocks;

  @override
  $Res call({
    Object? subarea = freezed,
  }) {
    return _then(_ToRocks(
      subarea == freezed
          ? _value.subarea
          : subarea // ignore: cast_nullable_to_non_nullable
              as SubareaBloc,
    ));
  }
}

/// @nodoc

class _$_ToRocks implements _ToRocks {
  const _$_ToRocks(this.subarea);

  @override
  final SubareaBloc subarea;

  @override
  String toString() {
    return 'ViewEvent.toRocks(subarea: $subarea)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToRocks &&
            (identical(other.subarea, subarea) ||
                const DeepCollectionEquality().equals(other.subarea, subarea)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(subarea);

  @JsonKey(ignore: true)
  @override
  _$ToRocksCopyWith<_ToRocks> get copyWith =>
      __$ToRocksCopyWithImpl<_ToRocks>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRocks(subarea);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocks != null) {
      return toRocks(subarea);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRocks(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocks != null) {
      return toRocks(this);
    }
    return orElse();
  }
}

abstract class _ToRocks implements ViewEvent {
  const factory _ToRocks(SubareaBloc subarea) = _$_ToRocks;

  SubareaBloc get subarea => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToRocksCopyWith<_ToRocks> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToRoutesCopyWith<$Res> {
  factory _$ToRoutesCopyWith(_ToRoutes value, $Res Function(_ToRoutes) then) =
      __$ToRoutesCopyWithImpl<$Res>;
  $Res call({RockBloc rock});
}

/// @nodoc
class __$ToRoutesCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRoutesCopyWith<$Res> {
  __$ToRoutesCopyWithImpl(_ToRoutes _value, $Res Function(_ToRoutes) _then)
      : super(_value, (v) => _then(v as _ToRoutes));

  @override
  _ToRoutes get _value => super._value as _ToRoutes;

  @override
  $Res call({
    Object? rock = freezed,
  }) {
    return _then(_ToRoutes(
      rock == freezed
          ? _value.rock
          : rock // ignore: cast_nullable_to_non_nullable
              as RockBloc,
    ));
  }
}

/// @nodoc

class _$_ToRoutes implements _ToRoutes {
  const _$_ToRoutes(this.rock);

  @override
  final RockBloc rock;

  @override
  String toString() {
    return 'ViewEvent.toRoutes(rock: $rock)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToRoutes &&
            (identical(other.rock, rock) ||
                const DeepCollectionEquality().equals(other.rock, rock)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(rock);

  @JsonKey(ignore: true)
  @override
  _$ToRoutesCopyWith<_ToRoutes> get copyWith =>
      __$ToRoutesCopyWithImpl<_ToRoutes>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRoutes(rock);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutes != null) {
      return toRoutes(rock);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRoutes(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutes != null) {
      return toRoutes(this);
    }
    return orElse();
  }
}

abstract class _ToRoutes implements ViewEvent {
  const factory _ToRoutes(RockBloc rock) = _$_ToRoutes;

  RockBloc get rock => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToRoutesCopyWith<_ToRoutes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToCountriesWithoutReloadCopyWith<$Res> {
  factory _$ToCountriesWithoutReloadCopyWith(_ToCountriesWithoutReload value,
          $Res Function(_ToCountriesWithoutReload) then) =
      __$ToCountriesWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToCountriesWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToCountriesWithoutReloadCopyWith<$Res> {
  __$ToCountriesWithoutReloadCopyWithImpl(_ToCountriesWithoutReload _value,
      $Res Function(_ToCountriesWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToCountriesWithoutReload));

  @override
  _ToCountriesWithoutReload get _value =>
      super._value as _ToCountriesWithoutReload;
}

/// @nodoc

class _$_ToCountriesWithoutReload implements _ToCountriesWithoutReload {
  const _$_ToCountriesWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toCountriesWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToCountriesWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toCountriesWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountriesWithoutReload != null) {
      return toCountriesWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toCountriesWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountriesWithoutReload != null) {
      return toCountriesWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToCountriesWithoutReload implements ViewEvent {
  const factory _ToCountriesWithoutReload() = _$_ToCountriesWithoutReload;
}

/// @nodoc
abstract class _$ToAreasWithoutReloadCopyWith<$Res> {
  factory _$ToAreasWithoutReloadCopyWith(_ToAreasWithoutReload value,
          $Res Function(_ToAreasWithoutReload) then) =
      __$ToAreasWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToAreasWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToAreasWithoutReloadCopyWith<$Res> {
  __$ToAreasWithoutReloadCopyWithImpl(
      _ToAreasWithoutReload _value, $Res Function(_ToAreasWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToAreasWithoutReload));

  @override
  _ToAreasWithoutReload get _value => super._value as _ToAreasWithoutReload;
}

/// @nodoc

class _$_ToAreasWithoutReload implements _ToAreasWithoutReload {
  const _$_ToAreasWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toAreasWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToAreasWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toAreasWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreasWithoutReload != null) {
      return toAreasWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toAreasWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreasWithoutReload != null) {
      return toAreasWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToAreasWithoutReload implements ViewEvent {
  const factory _ToAreasWithoutReload() = _$_ToAreasWithoutReload;
}

/// @nodoc
abstract class _$ToSubareasWithoutReloadCopyWith<$Res> {
  factory _$ToSubareasWithoutReloadCopyWith(_ToSubareasWithoutReload value,
          $Res Function(_ToSubareasWithoutReload) then) =
      __$ToSubareasWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToSubareasWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToSubareasWithoutReloadCopyWith<$Res> {
  __$ToSubareasWithoutReloadCopyWithImpl(_ToSubareasWithoutReload _value,
      $Res Function(_ToSubareasWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToSubareasWithoutReload));

  @override
  _ToSubareasWithoutReload get _value =>
      super._value as _ToSubareasWithoutReload;
}

/// @nodoc

class _$_ToSubareasWithoutReload implements _ToSubareasWithoutReload {
  const _$_ToSubareasWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toSubareasWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToSubareasWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toSubareasWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareasWithoutReload != null) {
      return toSubareasWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toSubareasWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareasWithoutReload != null) {
      return toSubareasWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToSubareasWithoutReload implements ViewEvent {
  const factory _ToSubareasWithoutReload() = _$_ToSubareasWithoutReload;
}

/// @nodoc
abstract class _$ToRocksWithoutReloadCopyWith<$Res> {
  factory _$ToRocksWithoutReloadCopyWith(_ToRocksWithoutReload value,
          $Res Function(_ToRocksWithoutReload) then) =
      __$ToRocksWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToRocksWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRocksWithoutReloadCopyWith<$Res> {
  __$ToRocksWithoutReloadCopyWithImpl(
      _ToRocksWithoutReload _value, $Res Function(_ToRocksWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToRocksWithoutReload));

  @override
  _ToRocksWithoutReload get _value => super._value as _ToRocksWithoutReload;
}

/// @nodoc

class _$_ToRocksWithoutReload implements _ToRocksWithoutReload {
  const _$_ToRocksWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toRocksWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToRocksWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRocksWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocksWithoutReload != null) {
      return toRocksWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRocksWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocksWithoutReload != null) {
      return toRocksWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToRocksWithoutReload implements ViewEvent {
  const factory _ToRocksWithoutReload() = _$_ToRocksWithoutReload;
}

/// @nodoc
abstract class _$ToRoutesWithoutReloadCopyWith<$Res> {
  factory _$ToRoutesWithoutReloadCopyWith(_ToRoutesWithoutReload value,
          $Res Function(_ToRoutesWithoutReload) then) =
      __$ToRoutesWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToRoutesWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRoutesWithoutReloadCopyWith<$Res> {
  __$ToRoutesWithoutReloadCopyWithImpl(_ToRoutesWithoutReload _value,
      $Res Function(_ToRoutesWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToRoutesWithoutReload));

  @override
  _ToRoutesWithoutReload get _value => super._value as _ToRoutesWithoutReload;
}

/// @nodoc

class _$_ToRoutesWithoutReload implements _ToRoutesWithoutReload {
  const _$_ToRoutesWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toRoutesWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToRoutesWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(CountryBloc country) toAreas,
    required TResult Function(AreaBloc area) toSubareas,
    required TResult Function(SubareaBloc subarea) toRocks,
    required TResult Function(RockBloc rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRoutesWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(CountryBloc country)? toAreas,
    TResult Function(AreaBloc area)? toSubareas,
    TResult Function(SubareaBloc subarea)? toRocks,
    TResult Function(RockBloc rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutesWithoutReload != null) {
      return toRoutesWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRoutesWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutesWithoutReload != null) {
      return toRoutesWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToRoutesWithoutReload implements ViewEvent {
  const factory _ToRoutesWithoutReload() = _$_ToRoutesWithoutReload;
}

/// @nodoc
class _$ViewStateTearOff {
  const _$ViewStateTearOff();

  _Initial initial() {
    return const _Initial();
  }

  _Countries countries() {
    return const _Countries();
  }

  _Areas areas(CountryBloc countryBloc) {
    return _Areas(
      countryBloc,
    );
  }

  _Subareas subareas(AreaBloc areaBloc) {
    return _Subareas(
      areaBloc,
    );
  }

  _Rocks rocks(SubareaBloc subareaBloc) {
    return _Rocks(
      subareaBloc,
    );
  }

  _Routes routes(RockBloc rockBloc) {
    return _Routes(
      rockBloc,
    );
  }
}

/// @nodoc
const $ViewState = _$ViewStateTearOff();

/// @nodoc
mixin _$ViewState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() countries,
    required TResult Function(CountryBloc countryBloc) areas,
    required TResult Function(AreaBloc areaBloc) subareas,
    required TResult Function(SubareaBloc subareaBloc) rocks,
    required TResult Function(RockBloc rockBloc) routes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? countries,
    TResult Function(CountryBloc countryBloc)? areas,
    TResult Function(AreaBloc areaBloc)? subareas,
    TResult Function(SubareaBloc subareaBloc)? rocks,
    TResult Function(RockBloc rockBloc)? routes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ViewStateCopyWith<$Res> {
  factory $ViewStateCopyWith(ViewState value, $Res Function(ViewState) then) =
      _$ViewStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ViewStateCopyWithImpl<$Res> implements $ViewStateCopyWith<$Res> {
  _$ViewStateCopyWithImpl(this._value, this._then);

  final ViewState _value;
  // ignore: unused_field
  final $Res Function(ViewState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'ViewState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() countries,
    required TResult Function(CountryBloc countryBloc) areas,
    required TResult Function(AreaBloc areaBloc) subareas,
    required TResult Function(SubareaBloc subareaBloc) rocks,
    required TResult Function(RockBloc rockBloc) routes,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? countries,
    TResult Function(CountryBloc countryBloc)? areas,
    TResult Function(AreaBloc areaBloc)? subareas,
    TResult Function(SubareaBloc subareaBloc)? rocks,
    TResult Function(RockBloc rockBloc)? routes,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements ViewState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$CountriesCopyWith<$Res> {
  factory _$CountriesCopyWith(
          _Countries value, $Res Function(_Countries) then) =
      __$CountriesCopyWithImpl<$Res>;
}

/// @nodoc
class __$CountriesCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$CountriesCopyWith<$Res> {
  __$CountriesCopyWithImpl(_Countries _value, $Res Function(_Countries) _then)
      : super(_value, (v) => _then(v as _Countries));

  @override
  _Countries get _value => super._value as _Countries;
}

/// @nodoc

class _$_Countries implements _Countries {
  const _$_Countries();

  @override
  String toString() {
    return 'ViewState.countries()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Countries);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() countries,
    required TResult Function(CountryBloc countryBloc) areas,
    required TResult Function(AreaBloc areaBloc) subareas,
    required TResult Function(SubareaBloc subareaBloc) rocks,
    required TResult Function(RockBloc rockBloc) routes,
  }) {
    return countries();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? countries,
    TResult Function(CountryBloc countryBloc)? areas,
    TResult Function(AreaBloc areaBloc)? subareas,
    TResult Function(SubareaBloc subareaBloc)? rocks,
    TResult Function(RockBloc rockBloc)? routes,
    required TResult orElse(),
  }) {
    if (countries != null) {
      return countries();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return countries(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (countries != null) {
      return countries(this);
    }
    return orElse();
  }
}

abstract class _Countries implements ViewState {
  const factory _Countries() = _$_Countries;
}

/// @nodoc
abstract class _$AreasCopyWith<$Res> {
  factory _$AreasCopyWith(_Areas value, $Res Function(_Areas) then) =
      __$AreasCopyWithImpl<$Res>;
  $Res call({CountryBloc countryBloc});
}

/// @nodoc
class __$AreasCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$AreasCopyWith<$Res> {
  __$AreasCopyWithImpl(_Areas _value, $Res Function(_Areas) _then)
      : super(_value, (v) => _then(v as _Areas));

  @override
  _Areas get _value => super._value as _Areas;

  @override
  $Res call({
    Object? countryBloc = freezed,
  }) {
    return _then(_Areas(
      countryBloc == freezed
          ? _value.countryBloc
          : countryBloc // ignore: cast_nullable_to_non_nullable
              as CountryBloc,
    ));
  }
}

/// @nodoc

class _$_Areas implements _Areas {
  const _$_Areas(this.countryBloc);

  @override
  final CountryBloc countryBloc;

  @override
  String toString() {
    return 'ViewState.areas(countryBloc: $countryBloc)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Areas &&
            (identical(other.countryBloc, countryBloc) ||
                const DeepCollectionEquality()
                    .equals(other.countryBloc, countryBloc)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(countryBloc);

  @JsonKey(ignore: true)
  @override
  _$AreasCopyWith<_Areas> get copyWith =>
      __$AreasCopyWithImpl<_Areas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() countries,
    required TResult Function(CountryBloc countryBloc) areas,
    required TResult Function(AreaBloc areaBloc) subareas,
    required TResult Function(SubareaBloc subareaBloc) rocks,
    required TResult Function(RockBloc rockBloc) routes,
  }) {
    return areas(countryBloc);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? countries,
    TResult Function(CountryBloc countryBloc)? areas,
    TResult Function(AreaBloc areaBloc)? subareas,
    TResult Function(SubareaBloc subareaBloc)? rocks,
    TResult Function(RockBloc rockBloc)? routes,
    required TResult orElse(),
  }) {
    if (areas != null) {
      return areas(countryBloc);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return areas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (areas != null) {
      return areas(this);
    }
    return orElse();
  }
}

abstract class _Areas implements ViewState {
  const factory _Areas(CountryBloc countryBloc) = _$_Areas;

  CountryBloc get countryBloc => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$AreasCopyWith<_Areas> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SubareasCopyWith<$Res> {
  factory _$SubareasCopyWith(_Subareas value, $Res Function(_Subareas) then) =
      __$SubareasCopyWithImpl<$Res>;
  $Res call({AreaBloc areaBloc});
}

/// @nodoc
class __$SubareasCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$SubareasCopyWith<$Res> {
  __$SubareasCopyWithImpl(_Subareas _value, $Res Function(_Subareas) _then)
      : super(_value, (v) => _then(v as _Subareas));

  @override
  _Subareas get _value => super._value as _Subareas;

  @override
  $Res call({
    Object? areaBloc = freezed,
  }) {
    return _then(_Subareas(
      areaBloc == freezed
          ? _value.areaBloc
          : areaBloc // ignore: cast_nullable_to_non_nullable
              as AreaBloc,
    ));
  }
}

/// @nodoc

class _$_Subareas implements _Subareas {
  const _$_Subareas(this.areaBloc);

  @override
  final AreaBloc areaBloc;

  @override
  String toString() {
    return 'ViewState.subareas(areaBloc: $areaBloc)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Subareas &&
            (identical(other.areaBloc, areaBloc) ||
                const DeepCollectionEquality()
                    .equals(other.areaBloc, areaBloc)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(areaBloc);

  @JsonKey(ignore: true)
  @override
  _$SubareasCopyWith<_Subareas> get copyWith =>
      __$SubareasCopyWithImpl<_Subareas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() countries,
    required TResult Function(CountryBloc countryBloc) areas,
    required TResult Function(AreaBloc areaBloc) subareas,
    required TResult Function(SubareaBloc subareaBloc) rocks,
    required TResult Function(RockBloc rockBloc) routes,
  }) {
    return subareas(areaBloc);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? countries,
    TResult Function(CountryBloc countryBloc)? areas,
    TResult Function(AreaBloc areaBloc)? subareas,
    TResult Function(SubareaBloc subareaBloc)? rocks,
    TResult Function(RockBloc rockBloc)? routes,
    required TResult orElse(),
  }) {
    if (subareas != null) {
      return subareas(areaBloc);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return subareas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (subareas != null) {
      return subareas(this);
    }
    return orElse();
  }
}

abstract class _Subareas implements ViewState {
  const factory _Subareas(AreaBloc areaBloc) = _$_Subareas;

  AreaBloc get areaBloc => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$SubareasCopyWith<_Subareas> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$RocksCopyWith<$Res> {
  factory _$RocksCopyWith(_Rocks value, $Res Function(_Rocks) then) =
      __$RocksCopyWithImpl<$Res>;
  $Res call({SubareaBloc subareaBloc});
}

/// @nodoc
class __$RocksCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$RocksCopyWith<$Res> {
  __$RocksCopyWithImpl(_Rocks _value, $Res Function(_Rocks) _then)
      : super(_value, (v) => _then(v as _Rocks));

  @override
  _Rocks get _value => super._value as _Rocks;

  @override
  $Res call({
    Object? subareaBloc = freezed,
  }) {
    return _then(_Rocks(
      subareaBloc == freezed
          ? _value.subareaBloc
          : subareaBloc // ignore: cast_nullable_to_non_nullable
              as SubareaBloc,
    ));
  }
}

/// @nodoc

class _$_Rocks implements _Rocks {
  const _$_Rocks(this.subareaBloc);

  @override
  final SubareaBloc subareaBloc;

  @override
  String toString() {
    return 'ViewState.rocks(subareaBloc: $subareaBloc)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Rocks &&
            (identical(other.subareaBloc, subareaBloc) ||
                const DeepCollectionEquality()
                    .equals(other.subareaBloc, subareaBloc)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(subareaBloc);

  @JsonKey(ignore: true)
  @override
  _$RocksCopyWith<_Rocks> get copyWith =>
      __$RocksCopyWithImpl<_Rocks>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() countries,
    required TResult Function(CountryBloc countryBloc) areas,
    required TResult Function(AreaBloc areaBloc) subareas,
    required TResult Function(SubareaBloc subareaBloc) rocks,
    required TResult Function(RockBloc rockBloc) routes,
  }) {
    return rocks(subareaBloc);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? countries,
    TResult Function(CountryBloc countryBloc)? areas,
    TResult Function(AreaBloc areaBloc)? subareas,
    TResult Function(SubareaBloc subareaBloc)? rocks,
    TResult Function(RockBloc rockBloc)? routes,
    required TResult orElse(),
  }) {
    if (rocks != null) {
      return rocks(subareaBloc);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return rocks(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (rocks != null) {
      return rocks(this);
    }
    return orElse();
  }
}

abstract class _Rocks implements ViewState {
  const factory _Rocks(SubareaBloc subareaBloc) = _$_Rocks;

  SubareaBloc get subareaBloc => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$RocksCopyWith<_Rocks> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$RoutesCopyWith<$Res> {
  factory _$RoutesCopyWith(_Routes value, $Res Function(_Routes) then) =
      __$RoutesCopyWithImpl<$Res>;
  $Res call({RockBloc rockBloc});
}

/// @nodoc
class __$RoutesCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$RoutesCopyWith<$Res> {
  __$RoutesCopyWithImpl(_Routes _value, $Res Function(_Routes) _then)
      : super(_value, (v) => _then(v as _Routes));

  @override
  _Routes get _value => super._value as _Routes;

  @override
  $Res call({
    Object? rockBloc = freezed,
  }) {
    return _then(_Routes(
      rockBloc == freezed
          ? _value.rockBloc
          : rockBloc // ignore: cast_nullable_to_non_nullable
              as RockBloc,
    ));
  }
}

/// @nodoc

class _$_Routes implements _Routes {
  const _$_Routes(this.rockBloc);

  @override
  final RockBloc rockBloc;

  @override
  String toString() {
    return 'ViewState.routes(rockBloc: $rockBloc)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Routes &&
            (identical(other.rockBloc, rockBloc) ||
                const DeepCollectionEquality()
                    .equals(other.rockBloc, rockBloc)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(rockBloc);

  @JsonKey(ignore: true)
  @override
  _$RoutesCopyWith<_Routes> get copyWith =>
      __$RoutesCopyWithImpl<_Routes>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() countries,
    required TResult Function(CountryBloc countryBloc) areas,
    required TResult Function(AreaBloc areaBloc) subareas,
    required TResult Function(SubareaBloc subareaBloc) rocks,
    required TResult Function(RockBloc rockBloc) routes,
  }) {
    return routes(rockBloc);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? countries,
    TResult Function(CountryBloc countryBloc)? areas,
    TResult Function(AreaBloc areaBloc)? subareas,
    TResult Function(SubareaBloc subareaBloc)? rocks,
    TResult Function(RockBloc rockBloc)? routes,
    required TResult orElse(),
  }) {
    if (routes != null) {
      return routes(rockBloc);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return routes(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (routes != null) {
      return routes(this);
    }
    return orElse();
  }
}

abstract class _Routes implements ViewState {
  const factory _Routes(RockBloc rockBloc) = _$_Routes;

  RockBloc get rockBloc => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$RoutesCopyWith<_Routes> get copyWith => throw _privateConstructorUsedError;
}
