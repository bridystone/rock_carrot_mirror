// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'view_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ViewEventTearOff {
  const _$ViewEventTearOff();

  _ToCountries toCountries() {
    return const _ToCountries();
  }

  _ToAreas toAreas(Country country) {
    return _ToAreas(
      country,
    );
  }

  _ToSubareas toSubareas(Area area) {
    return _ToSubareas(
      area,
    );
  }

  _ToRocks toRocks(Subarea subarea) {
    return _ToRocks(
      subarea,
    );
  }

  _ToRoutes toRoutes(Rock rock) {
    return _ToRoutes(
      rock,
    );
  }

  _ToCountriesWithoutReload toCountriesWithoutReload() {
    return const _ToCountriesWithoutReload();
  }

  _ToAreasWithoutReload toAreasWithoutReload() {
    return const _ToAreasWithoutReload();
  }

  _ToSubareasWithoutReload toSubareasWithoutReload() {
    return const _ToSubareasWithoutReload();
  }

  _ToRocksWithoutReload toRocksWithoutReload() {
    return const _ToRocksWithoutReload();
  }

  _ToRoutesWithoutReload toRoutesWithoutReload() {
    return const _ToRoutesWithoutReload();
  }
}

/// @nodoc
const $ViewEvent = _$ViewEventTearOff();

/// @nodoc
mixin _$ViewEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ViewEventCopyWith<$Res> {
  factory $ViewEventCopyWith(ViewEvent value, $Res Function(ViewEvent) then) =
      _$ViewEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$ViewEventCopyWithImpl<$Res> implements $ViewEventCopyWith<$Res> {
  _$ViewEventCopyWithImpl(this._value, this._then);

  final ViewEvent _value;
  // ignore: unused_field
  final $Res Function(ViewEvent) _then;
}

/// @nodoc
abstract class _$ToCountriesCopyWith<$Res> {
  factory _$ToCountriesCopyWith(
          _ToCountries value, $Res Function(_ToCountries) then) =
      __$ToCountriesCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToCountriesCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToCountriesCopyWith<$Res> {
  __$ToCountriesCopyWithImpl(
      _ToCountries _value, $Res Function(_ToCountries) _then)
      : super(_value, (v) => _then(v as _ToCountries));

  @override
  _ToCountries get _value => super._value as _ToCountries;
}

/// @nodoc

class _$_ToCountries implements _ToCountries {
  const _$_ToCountries();

  @override
  String toString() {
    return 'ViewEvent.toCountries()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToCountries);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toCountries();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountries != null) {
      return toCountries();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toCountries(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountries != null) {
      return toCountries(this);
    }
    return orElse();
  }
}

abstract class _ToCountries implements ViewEvent {
  const factory _ToCountries() = _$_ToCountries;
}

/// @nodoc
abstract class _$ToAreasCopyWith<$Res> {
  factory _$ToAreasCopyWith(_ToAreas value, $Res Function(_ToAreas) then) =
      __$ToAreasCopyWithImpl<$Res>;
  $Res call({Country country});
}

/// @nodoc
class __$ToAreasCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToAreasCopyWith<$Res> {
  __$ToAreasCopyWithImpl(_ToAreas _value, $Res Function(_ToAreas) _then)
      : super(_value, (v) => _then(v as _ToAreas));

  @override
  _ToAreas get _value => super._value as _ToAreas;

  @override
  $Res call({
    Object? country = freezed,
  }) {
    return _then(_ToAreas(
      country == freezed
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as Country,
    ));
  }
}

/// @nodoc

class _$_ToAreas implements _ToAreas {
  const _$_ToAreas(this.country);

  @override
  final Country country;

  @override
  String toString() {
    return 'ViewEvent.toAreas(country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToAreas &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(country);

  @JsonKey(ignore: true)
  @override
  _$ToAreasCopyWith<_ToAreas> get copyWith =>
      __$ToAreasCopyWithImpl<_ToAreas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toAreas(country);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreas != null) {
      return toAreas(country);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toAreas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreas != null) {
      return toAreas(this);
    }
    return orElse();
  }
}

abstract class _ToAreas implements ViewEvent {
  const factory _ToAreas(Country country) = _$_ToAreas;

  Country get country => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToAreasCopyWith<_ToAreas> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToSubareasCopyWith<$Res> {
  factory _$ToSubareasCopyWith(
          _ToSubareas value, $Res Function(_ToSubareas) then) =
      __$ToSubareasCopyWithImpl<$Res>;
  $Res call({Area area});
}

/// @nodoc
class __$ToSubareasCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToSubareasCopyWith<$Res> {
  __$ToSubareasCopyWithImpl(
      _ToSubareas _value, $Res Function(_ToSubareas) _then)
      : super(_value, (v) => _then(v as _ToSubareas));

  @override
  _ToSubareas get _value => super._value as _ToSubareas;

  @override
  $Res call({
    Object? area = freezed,
  }) {
    return _then(_ToSubareas(
      area == freezed
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as Area,
    ));
  }
}

/// @nodoc

class _$_ToSubareas implements _ToSubareas {
  const _$_ToSubareas(this.area);

  @override
  final Area area;

  @override
  String toString() {
    return 'ViewEvent.toSubareas(area: $area)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToSubareas &&
            (identical(other.area, area) ||
                const DeepCollectionEquality().equals(other.area, area)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(area);

  @JsonKey(ignore: true)
  @override
  _$ToSubareasCopyWith<_ToSubareas> get copyWith =>
      __$ToSubareasCopyWithImpl<_ToSubareas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toSubareas(area);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareas != null) {
      return toSubareas(area);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toSubareas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareas != null) {
      return toSubareas(this);
    }
    return orElse();
  }
}

abstract class _ToSubareas implements ViewEvent {
  const factory _ToSubareas(Area area) = _$_ToSubareas;

  Area get area => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToSubareasCopyWith<_ToSubareas> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToRocksCopyWith<$Res> {
  factory _$ToRocksCopyWith(_ToRocks value, $Res Function(_ToRocks) then) =
      __$ToRocksCopyWithImpl<$Res>;
  $Res call({Subarea subarea});
}

/// @nodoc
class __$ToRocksCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRocksCopyWith<$Res> {
  __$ToRocksCopyWithImpl(_ToRocks _value, $Res Function(_ToRocks) _then)
      : super(_value, (v) => _then(v as _ToRocks));

  @override
  _ToRocks get _value => super._value as _ToRocks;

  @override
  $Res call({
    Object? subarea = freezed,
  }) {
    return _then(_ToRocks(
      subarea == freezed
          ? _value.subarea
          : subarea // ignore: cast_nullable_to_non_nullable
              as Subarea,
    ));
  }
}

/// @nodoc

class _$_ToRocks implements _ToRocks {
  const _$_ToRocks(this.subarea);

  @override
  final Subarea subarea;

  @override
  String toString() {
    return 'ViewEvent.toRocks(subarea: $subarea)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToRocks &&
            (identical(other.subarea, subarea) ||
                const DeepCollectionEquality().equals(other.subarea, subarea)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(subarea);

  @JsonKey(ignore: true)
  @override
  _$ToRocksCopyWith<_ToRocks> get copyWith =>
      __$ToRocksCopyWithImpl<_ToRocks>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRocks(subarea);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocks != null) {
      return toRocks(subarea);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRocks(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocks != null) {
      return toRocks(this);
    }
    return orElse();
  }
}

abstract class _ToRocks implements ViewEvent {
  const factory _ToRocks(Subarea subarea) = _$_ToRocks;

  Subarea get subarea => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToRocksCopyWith<_ToRocks> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToRoutesCopyWith<$Res> {
  factory _$ToRoutesCopyWith(_ToRoutes value, $Res Function(_ToRoutes) then) =
      __$ToRoutesCopyWithImpl<$Res>;
  $Res call({Rock rock});
}

/// @nodoc
class __$ToRoutesCopyWithImpl<$Res> extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRoutesCopyWith<$Res> {
  __$ToRoutesCopyWithImpl(_ToRoutes _value, $Res Function(_ToRoutes) _then)
      : super(_value, (v) => _then(v as _ToRoutes));

  @override
  _ToRoutes get _value => super._value as _ToRoutes;

  @override
  $Res call({
    Object? rock = freezed,
  }) {
    return _then(_ToRoutes(
      rock == freezed
          ? _value.rock
          : rock // ignore: cast_nullable_to_non_nullable
              as Rock,
    ));
  }
}

/// @nodoc

class _$_ToRoutes implements _ToRoutes {
  const _$_ToRoutes(this.rock);

  @override
  final Rock rock;

  @override
  String toString() {
    return 'ViewEvent.toRoutes(rock: $rock)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ToRoutes &&
            (identical(other.rock, rock) ||
                const DeepCollectionEquality().equals(other.rock, rock)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(rock);

  @JsonKey(ignore: true)
  @override
  _$ToRoutesCopyWith<_ToRoutes> get copyWith =>
      __$ToRoutesCopyWithImpl<_ToRoutes>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRoutes(rock);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutes != null) {
      return toRoutes(rock);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRoutes(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutes != null) {
      return toRoutes(this);
    }
    return orElse();
  }
}

abstract class _ToRoutes implements ViewEvent {
  const factory _ToRoutes(Rock rock) = _$_ToRoutes;

  Rock get rock => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$ToRoutesCopyWith<_ToRoutes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ToCountriesWithoutReloadCopyWith<$Res> {
  factory _$ToCountriesWithoutReloadCopyWith(_ToCountriesWithoutReload value,
          $Res Function(_ToCountriesWithoutReload) then) =
      __$ToCountriesWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToCountriesWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToCountriesWithoutReloadCopyWith<$Res> {
  __$ToCountriesWithoutReloadCopyWithImpl(_ToCountriesWithoutReload _value,
      $Res Function(_ToCountriesWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToCountriesWithoutReload));

  @override
  _ToCountriesWithoutReload get _value =>
      super._value as _ToCountriesWithoutReload;
}

/// @nodoc

class _$_ToCountriesWithoutReload implements _ToCountriesWithoutReload {
  const _$_ToCountriesWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toCountriesWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToCountriesWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toCountriesWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountriesWithoutReload != null) {
      return toCountriesWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toCountriesWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toCountriesWithoutReload != null) {
      return toCountriesWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToCountriesWithoutReload implements ViewEvent {
  const factory _ToCountriesWithoutReload() = _$_ToCountriesWithoutReload;
}

/// @nodoc
abstract class _$ToAreasWithoutReloadCopyWith<$Res> {
  factory _$ToAreasWithoutReloadCopyWith(_ToAreasWithoutReload value,
          $Res Function(_ToAreasWithoutReload) then) =
      __$ToAreasWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToAreasWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToAreasWithoutReloadCopyWith<$Res> {
  __$ToAreasWithoutReloadCopyWithImpl(
      _ToAreasWithoutReload _value, $Res Function(_ToAreasWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToAreasWithoutReload));

  @override
  _ToAreasWithoutReload get _value => super._value as _ToAreasWithoutReload;
}

/// @nodoc

class _$_ToAreasWithoutReload implements _ToAreasWithoutReload {
  const _$_ToAreasWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toAreasWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToAreasWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toAreasWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreasWithoutReload != null) {
      return toAreasWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toAreasWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toAreasWithoutReload != null) {
      return toAreasWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToAreasWithoutReload implements ViewEvent {
  const factory _ToAreasWithoutReload() = _$_ToAreasWithoutReload;
}

/// @nodoc
abstract class _$ToSubareasWithoutReloadCopyWith<$Res> {
  factory _$ToSubareasWithoutReloadCopyWith(_ToSubareasWithoutReload value,
          $Res Function(_ToSubareasWithoutReload) then) =
      __$ToSubareasWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToSubareasWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToSubareasWithoutReloadCopyWith<$Res> {
  __$ToSubareasWithoutReloadCopyWithImpl(_ToSubareasWithoutReload _value,
      $Res Function(_ToSubareasWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToSubareasWithoutReload));

  @override
  _ToSubareasWithoutReload get _value =>
      super._value as _ToSubareasWithoutReload;
}

/// @nodoc

class _$_ToSubareasWithoutReload implements _ToSubareasWithoutReload {
  const _$_ToSubareasWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toSubareasWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToSubareasWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toSubareasWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareasWithoutReload != null) {
      return toSubareasWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toSubareasWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toSubareasWithoutReload != null) {
      return toSubareasWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToSubareasWithoutReload implements ViewEvent {
  const factory _ToSubareasWithoutReload() = _$_ToSubareasWithoutReload;
}

/// @nodoc
abstract class _$ToRocksWithoutReloadCopyWith<$Res> {
  factory _$ToRocksWithoutReloadCopyWith(_ToRocksWithoutReload value,
          $Res Function(_ToRocksWithoutReload) then) =
      __$ToRocksWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToRocksWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRocksWithoutReloadCopyWith<$Res> {
  __$ToRocksWithoutReloadCopyWithImpl(
      _ToRocksWithoutReload _value, $Res Function(_ToRocksWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToRocksWithoutReload));

  @override
  _ToRocksWithoutReload get _value => super._value as _ToRocksWithoutReload;
}

/// @nodoc

class _$_ToRocksWithoutReload implements _ToRocksWithoutReload {
  const _$_ToRocksWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toRocksWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToRocksWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRocksWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocksWithoutReload != null) {
      return toRocksWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRocksWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRocksWithoutReload != null) {
      return toRocksWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToRocksWithoutReload implements ViewEvent {
  const factory _ToRocksWithoutReload() = _$_ToRocksWithoutReload;
}

/// @nodoc
abstract class _$ToRoutesWithoutReloadCopyWith<$Res> {
  factory _$ToRoutesWithoutReloadCopyWith(_ToRoutesWithoutReload value,
          $Res Function(_ToRoutesWithoutReload) then) =
      __$ToRoutesWithoutReloadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ToRoutesWithoutReloadCopyWithImpl<$Res>
    extends _$ViewEventCopyWithImpl<$Res>
    implements _$ToRoutesWithoutReloadCopyWith<$Res> {
  __$ToRoutesWithoutReloadCopyWithImpl(_ToRoutesWithoutReload _value,
      $Res Function(_ToRoutesWithoutReload) _then)
      : super(_value, (v) => _then(v as _ToRoutesWithoutReload));

  @override
  _ToRoutesWithoutReload get _value => super._value as _ToRoutesWithoutReload;
}

/// @nodoc

class _$_ToRoutesWithoutReload implements _ToRoutesWithoutReload {
  const _$_ToRoutesWithoutReload();

  @override
  String toString() {
    return 'ViewEvent.toRoutesWithoutReload()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ToRoutesWithoutReload);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() toCountries,
    required TResult Function(Country country) toAreas,
    required TResult Function(Area area) toSubareas,
    required TResult Function(Subarea subarea) toRocks,
    required TResult Function(Rock rock) toRoutes,
    required TResult Function() toCountriesWithoutReload,
    required TResult Function() toAreasWithoutReload,
    required TResult Function() toSubareasWithoutReload,
    required TResult Function() toRocksWithoutReload,
    required TResult Function() toRoutesWithoutReload,
  }) {
    return toRoutesWithoutReload();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? toCountries,
    TResult Function(Country country)? toAreas,
    TResult Function(Area area)? toSubareas,
    TResult Function(Subarea subarea)? toRocks,
    TResult Function(Rock rock)? toRoutes,
    TResult Function()? toCountriesWithoutReload,
    TResult Function()? toAreasWithoutReload,
    TResult Function()? toSubareasWithoutReload,
    TResult Function()? toRocksWithoutReload,
    TResult Function()? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutesWithoutReload != null) {
      return toRoutesWithoutReload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ToCountries value) toCountries,
    required TResult Function(_ToAreas value) toAreas,
    required TResult Function(_ToSubareas value) toSubareas,
    required TResult Function(_ToRocks value) toRocks,
    required TResult Function(_ToRoutes value) toRoutes,
    required TResult Function(_ToCountriesWithoutReload value)
        toCountriesWithoutReload,
    required TResult Function(_ToAreasWithoutReload value) toAreasWithoutReload,
    required TResult Function(_ToSubareasWithoutReload value)
        toSubareasWithoutReload,
    required TResult Function(_ToRocksWithoutReload value) toRocksWithoutReload,
    required TResult Function(_ToRoutesWithoutReload value)
        toRoutesWithoutReload,
  }) {
    return toRoutesWithoutReload(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ToCountries value)? toCountries,
    TResult Function(_ToAreas value)? toAreas,
    TResult Function(_ToSubareas value)? toSubareas,
    TResult Function(_ToRocks value)? toRocks,
    TResult Function(_ToRoutes value)? toRoutes,
    TResult Function(_ToCountriesWithoutReload value)? toCountriesWithoutReload,
    TResult Function(_ToAreasWithoutReload value)? toAreasWithoutReload,
    TResult Function(_ToSubareasWithoutReload value)? toSubareasWithoutReload,
    TResult Function(_ToRocksWithoutReload value)? toRocksWithoutReload,
    TResult Function(_ToRoutesWithoutReload value)? toRoutesWithoutReload,
    required TResult orElse(),
  }) {
    if (toRoutesWithoutReload != null) {
      return toRoutesWithoutReload(this);
    }
    return orElse();
  }
}

abstract class _ToRoutesWithoutReload implements ViewEvent {
  const factory _ToRoutesWithoutReload() = _$_ToRoutesWithoutReload;
}

/// @nodoc
class _$ViewStateTearOff {
  const _$ViewStateTearOff();

  _Countries countries() {
    return const _Countries();
  }

  _Areas areas(Country country) {
    return _Areas(
      country,
    );
  }

  _Subareas subareas(Area area) {
    return _Subareas(
      area,
    );
  }

  _Rocks rocks(Subarea subarea) {
    return _Rocks(
      subarea,
    );
  }

  _Routes routes(Rock rock) {
    return _Routes(
      rock,
    );
  }
}

/// @nodoc
const $ViewState = _$ViewStateTearOff();

/// @nodoc
mixin _$ViewState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() countries,
    required TResult Function(Country country) areas,
    required TResult Function(Area area) subareas,
    required TResult Function(Subarea subarea) rocks,
    required TResult Function(Rock rock) routes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? countries,
    TResult Function(Country country)? areas,
    TResult Function(Area area)? subareas,
    TResult Function(Subarea subarea)? rocks,
    TResult Function(Rock rock)? routes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ViewStateCopyWith<$Res> {
  factory $ViewStateCopyWith(ViewState value, $Res Function(ViewState) then) =
      _$ViewStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ViewStateCopyWithImpl<$Res> implements $ViewStateCopyWith<$Res> {
  _$ViewStateCopyWithImpl(this._value, this._then);

  final ViewState _value;
  // ignore: unused_field
  final $Res Function(ViewState) _then;
}

/// @nodoc
abstract class _$CountriesCopyWith<$Res> {
  factory _$CountriesCopyWith(
          _Countries value, $Res Function(_Countries) then) =
      __$CountriesCopyWithImpl<$Res>;
}

/// @nodoc
class __$CountriesCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$CountriesCopyWith<$Res> {
  __$CountriesCopyWithImpl(_Countries _value, $Res Function(_Countries) _then)
      : super(_value, (v) => _then(v as _Countries));

  @override
  _Countries get _value => super._value as _Countries;
}

/// @nodoc

class _$_Countries implements _Countries {
  const _$_Countries();

  @override
  String toString() {
    return 'ViewState.countries()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Countries);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() countries,
    required TResult Function(Country country) areas,
    required TResult Function(Area area) subareas,
    required TResult Function(Subarea subarea) rocks,
    required TResult Function(Rock rock) routes,
  }) {
    return countries();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? countries,
    TResult Function(Country country)? areas,
    TResult Function(Area area)? subareas,
    TResult Function(Subarea subarea)? rocks,
    TResult Function(Rock rock)? routes,
    required TResult orElse(),
  }) {
    if (countries != null) {
      return countries();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return countries(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (countries != null) {
      return countries(this);
    }
    return orElse();
  }
}

abstract class _Countries implements ViewState {
  const factory _Countries() = _$_Countries;
}

/// @nodoc
abstract class _$AreasCopyWith<$Res> {
  factory _$AreasCopyWith(_Areas value, $Res Function(_Areas) then) =
      __$AreasCopyWithImpl<$Res>;
  $Res call({Country country});
}

/// @nodoc
class __$AreasCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$AreasCopyWith<$Res> {
  __$AreasCopyWithImpl(_Areas _value, $Res Function(_Areas) _then)
      : super(_value, (v) => _then(v as _Areas));

  @override
  _Areas get _value => super._value as _Areas;

  @override
  $Res call({
    Object? country = freezed,
  }) {
    return _then(_Areas(
      country == freezed
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as Country,
    ));
  }
}

/// @nodoc

class _$_Areas implements _Areas {
  const _$_Areas(this.country);

  @override
  final Country country;

  @override
  String toString() {
    return 'ViewState.areas(country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Areas &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(country);

  @JsonKey(ignore: true)
  @override
  _$AreasCopyWith<_Areas> get copyWith =>
      __$AreasCopyWithImpl<_Areas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() countries,
    required TResult Function(Country country) areas,
    required TResult Function(Area area) subareas,
    required TResult Function(Subarea subarea) rocks,
    required TResult Function(Rock rock) routes,
  }) {
    return areas(country);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? countries,
    TResult Function(Country country)? areas,
    TResult Function(Area area)? subareas,
    TResult Function(Subarea subarea)? rocks,
    TResult Function(Rock rock)? routes,
    required TResult orElse(),
  }) {
    if (areas != null) {
      return areas(country);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return areas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (areas != null) {
      return areas(this);
    }
    return orElse();
  }
}

abstract class _Areas implements ViewState {
  const factory _Areas(Country country) = _$_Areas;

  Country get country => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$AreasCopyWith<_Areas> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SubareasCopyWith<$Res> {
  factory _$SubareasCopyWith(_Subareas value, $Res Function(_Subareas) then) =
      __$SubareasCopyWithImpl<$Res>;
  $Res call({Area area});
}

/// @nodoc
class __$SubareasCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$SubareasCopyWith<$Res> {
  __$SubareasCopyWithImpl(_Subareas _value, $Res Function(_Subareas) _then)
      : super(_value, (v) => _then(v as _Subareas));

  @override
  _Subareas get _value => super._value as _Subareas;

  @override
  $Res call({
    Object? area = freezed,
  }) {
    return _then(_Subareas(
      area == freezed
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as Area,
    ));
  }
}

/// @nodoc

class _$_Subareas implements _Subareas {
  const _$_Subareas(this.area);

  @override
  final Area area;

  @override
  String toString() {
    return 'ViewState.subareas(area: $area)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Subareas &&
            (identical(other.area, area) ||
                const DeepCollectionEquality().equals(other.area, area)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(area);

  @JsonKey(ignore: true)
  @override
  _$SubareasCopyWith<_Subareas> get copyWith =>
      __$SubareasCopyWithImpl<_Subareas>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() countries,
    required TResult Function(Country country) areas,
    required TResult Function(Area area) subareas,
    required TResult Function(Subarea subarea) rocks,
    required TResult Function(Rock rock) routes,
  }) {
    return subareas(area);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? countries,
    TResult Function(Country country)? areas,
    TResult Function(Area area)? subareas,
    TResult Function(Subarea subarea)? rocks,
    TResult Function(Rock rock)? routes,
    required TResult orElse(),
  }) {
    if (subareas != null) {
      return subareas(area);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return subareas(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (subareas != null) {
      return subareas(this);
    }
    return orElse();
  }
}

abstract class _Subareas implements ViewState {
  const factory _Subareas(Area area) = _$_Subareas;

  Area get area => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$SubareasCopyWith<_Subareas> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$RocksCopyWith<$Res> {
  factory _$RocksCopyWith(_Rocks value, $Res Function(_Rocks) then) =
      __$RocksCopyWithImpl<$Res>;
  $Res call({Subarea subarea});
}

/// @nodoc
class __$RocksCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$RocksCopyWith<$Res> {
  __$RocksCopyWithImpl(_Rocks _value, $Res Function(_Rocks) _then)
      : super(_value, (v) => _then(v as _Rocks));

  @override
  _Rocks get _value => super._value as _Rocks;

  @override
  $Res call({
    Object? subarea = freezed,
  }) {
    return _then(_Rocks(
      subarea == freezed
          ? _value.subarea
          : subarea // ignore: cast_nullable_to_non_nullable
              as Subarea,
    ));
  }
}

/// @nodoc

class _$_Rocks implements _Rocks {
  const _$_Rocks(this.subarea);

  @override
  final Subarea subarea;

  @override
  String toString() {
    return 'ViewState.rocks(subarea: $subarea)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Rocks &&
            (identical(other.subarea, subarea) ||
                const DeepCollectionEquality().equals(other.subarea, subarea)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(subarea);

  @JsonKey(ignore: true)
  @override
  _$RocksCopyWith<_Rocks> get copyWith =>
      __$RocksCopyWithImpl<_Rocks>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() countries,
    required TResult Function(Country country) areas,
    required TResult Function(Area area) subareas,
    required TResult Function(Subarea subarea) rocks,
    required TResult Function(Rock rock) routes,
  }) {
    return rocks(subarea);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? countries,
    TResult Function(Country country)? areas,
    TResult Function(Area area)? subareas,
    TResult Function(Subarea subarea)? rocks,
    TResult Function(Rock rock)? routes,
    required TResult orElse(),
  }) {
    if (rocks != null) {
      return rocks(subarea);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return rocks(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (rocks != null) {
      return rocks(this);
    }
    return orElse();
  }
}

abstract class _Rocks implements ViewState {
  const factory _Rocks(Subarea subarea) = _$_Rocks;

  Subarea get subarea => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$RocksCopyWith<_Rocks> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$RoutesCopyWith<$Res> {
  factory _$RoutesCopyWith(_Routes value, $Res Function(_Routes) then) =
      __$RoutesCopyWithImpl<$Res>;
  $Res call({Rock rock});
}

/// @nodoc
class __$RoutesCopyWithImpl<$Res> extends _$ViewStateCopyWithImpl<$Res>
    implements _$RoutesCopyWith<$Res> {
  __$RoutesCopyWithImpl(_Routes _value, $Res Function(_Routes) _then)
      : super(_value, (v) => _then(v as _Routes));

  @override
  _Routes get _value => super._value as _Routes;

  @override
  $Res call({
    Object? rock = freezed,
  }) {
    return _then(_Routes(
      rock == freezed
          ? _value.rock
          : rock // ignore: cast_nullable_to_non_nullable
              as Rock,
    ));
  }
}

/// @nodoc

class _$_Routes implements _Routes {
  const _$_Routes(this.rock);

  @override
  final Rock rock;

  @override
  String toString() {
    return 'ViewState.routes(rock: $rock)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Routes &&
            (identical(other.rock, rock) ||
                const DeepCollectionEquality().equals(other.rock, rock)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(rock);

  @JsonKey(ignore: true)
  @override
  _$RoutesCopyWith<_Routes> get copyWith =>
      __$RoutesCopyWithImpl<_Routes>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() countries,
    required TResult Function(Country country) areas,
    required TResult Function(Area area) subareas,
    required TResult Function(Subarea subarea) rocks,
    required TResult Function(Rock rock) routes,
  }) {
    return routes(rock);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? countries,
    TResult Function(Country country)? areas,
    TResult Function(Area area)? subareas,
    TResult Function(Subarea subarea)? rocks,
    TResult Function(Rock rock)? routes,
    required TResult orElse(),
  }) {
    if (routes != null) {
      return routes(rock);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Countries value) countries,
    required TResult Function(_Areas value) areas,
    required TResult Function(_Subareas value) subareas,
    required TResult Function(_Rocks value) rocks,
    required TResult Function(_Routes value) routes,
  }) {
    return routes(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Countries value)? countries,
    TResult Function(_Areas value)? areas,
    TResult Function(_Subareas value)? subareas,
    TResult Function(_Rocks value)? rocks,
    TResult Function(_Routes value)? routes,
    required TResult orElse(),
  }) {
    if (routes != null) {
      return routes(this);
    }
    return orElse();
  }
}

abstract class _Routes implements ViewState {
  const factory _Routes(Rock rock) = _$_Routes;

  Rock get rock => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$RoutesCopyWith<_Routes> get copyWith => throw _privateConstructorUsedError;
}
